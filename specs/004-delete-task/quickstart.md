# Quickstart Guide: Delete Task Implementation

**Feature**: Delete Task (004-delete-task)
**Date**: 2025-12-31
**Audience**: Implementation engineers (AI agents via `/sp.implement`)

## Overview

This guide provides step-by-step instructions for implementing the Delete Task feature following Test-First Development (TDD) methodology. The implementation must strictly follow the RED-GREEN-REFACTOR cycle as mandated by Constitution Principle V.

## Prerequisites

**Before starting implementation**:
1. ‚úÖ Specification approved (`specs/004-delete-task/spec.md`)
2. ‚úÖ Implementation plan reviewed (`specs/004-delete-task/plan.md`)
3. ‚úÖ Research decisions documented (`specs/004-delete-task/research.md`)
4. ‚úÖ Data model defined (`specs/004-delete-task/data-model.md`)
5. ‚úÖ CLI interface contract specified (`specs/004-delete-task/contracts/cli-interface.md`)
6. ‚úÖ Task decomposition complete (`specs/004-delete-task/tasks.md`) - **Generated by `/sp.tasks`**

**Required Files** (already exist, no changes needed):
- `src/models/task.py` - Task dataclass and TaskStatus enum
- `src/services/task_service.py` - In-memory storage `_tasks: Dict[str, Task]`
- `src/main.py` - Command router
- `tests/unit/test_task_service.py` - Service layer tests
- `tests/integration/` - Integration test directory

## Implementation Workflow

### Phase 0: Setup (if needed)

**Status**: ‚úÖ No setup required - all infrastructure already exists from Add Task, View Task List, and Update Task features.

---

### Phase 1: RED - Write Failing Tests

**Mandate**: Tests MUST be written BEFORE implementation code. Tests MUST fail initially to validate they detect missing functionality.

#### Step 1.1: Write Unit Tests for Service Layer

**File**: `tests/unit/test_task_service.py`

**Import Addition**:
```python
from src.services.task_service import delete_task  # Add to existing imports
```

**Tests to Add** (6 tests total):

```python
# Test 1: Successful deletion returns Task object
def test_delete_task_returns_deleted_task():
    """Test that delete_task() returns the deleted Task object"""
    clear_tasks()
    task = create_task("Buy milk", "Get organic milk")

    deleted = delete_task(task.id)

    assert deleted.id == task.id
    assert deleted.title == "Buy milk"
    assert deleted.description == "Get organic milk"
    assert deleted.status == TaskStatus.INCOMPLETE


# Test 2: Task is removed from storage
def test_delete_task_removes_from_storage():
    """Test that deleted task is removed from storage"""
    clear_tasks()
    task = create_task("Buy milk")

    delete_task(task.id)

    # Verify task no longer exists
    with pytest.raises(KeyError):
        get_task(task.id)


# Test 3: Delete non-existent task raises KeyError
def test_delete_task_nonexistent_id_raises_keyerror():
    """Test that deleting non-existent task raises KeyError"""
    clear_tasks()

    with pytest.raises(KeyError, match="Task not found with ID"):
        delete_task("nonexistent-id")


# Test 4: Delete works for any task status
def test_delete_task_works_for_any_status():
    """Test that delete works regardless of task status"""
    clear_tasks()
    task1 = create_task("Incomplete task")
    task2 = create_task("Complete task")
    # Note: Status update functionality doesn't exist yet,
    # but this test verifies deletion doesn't check status

    deleted1 = delete_task(task1.id)
    deleted2 = delete_task(task2.id)

    assert deleted1.status == TaskStatus.INCOMPLETE
    assert deleted2.status == TaskStatus.INCOMPLETE


# Test 5: Delete task with Unicode characters
def test_delete_task_with_unicode():
    """Test deleting task with Unicode characters"""
    clear_tasks()
    task = create_task("Caf√© ‚òï", "Êó•Êú¨Ë™û üéâ")

    deleted = delete_task(task.id)

    assert deleted.title == "Caf√© ‚òï"
    assert deleted.description == "Êó•Êú¨Ë™û üéâ"


# Test 6: Delete only removes specified task
def test_delete_task_only_removes_specified_task():
    """Test that delete only removes the specified task, not others"""
    clear_tasks()
    task1 = create_task("Task 1")
    task2 = create_task("Task 2")
    task3 = create_task("Task 3")

    delete_task(task2.id)

    # Verify task1 and task3 still exist
    assert get_task(task1.id).title == "Task 1"
    assert get_task(task3.id).title == "Task 3"

    # Verify task2 is gone
    with pytest.raises(KeyError):
        get_task(task2.id)
```

#### Step 1.2: Write Integration Tests for CLI Layer

**File**: `tests/integration/test_delete_task_integration.py` (NEW FILE)

**Content**:
```python
import subprocess
import sys
from src.services.task_service import create_task, clear_tasks, delete_task as service_delete_task
from src.models.task import TaskStatus


def test_delete_task_in_process():
    """Test delete task success message (in-process test for Phase I)"""
    clear_tasks()
    task = create_task("Buy milk", "Get organic milk")

    # Delete via service layer (in-process test)
    deleted = service_delete_task(task.id)

    assert deleted.title == "Buy milk"
    assert deleted.description == "Get organic milk"

    # Verify task is removed
    from src.services.task_service import get_task
    import pytest
    with pytest.raises(KeyError):
        get_task(task.id)

    clear_tasks()


def test_delete_help():
    """Test that --help displays usage information"""
    result = subprocess.run(
        [sys.executable, '-m', 'src.main', 'delete', '--help'],
        capture_output=True,
        text=True
    )

    assert result.returncode == 0
    assert 'usage:' in result.stdout
    assert 'task_id' in result.stdout
    assert 'Delete an existing task' in result.stdout


def test_delete_nonexistent_task():
    """Test delete with non-existent task ID shows error"""
    clear_tasks()

    result = subprocess.run(
        [sys.executable, '-m', 'src.main', 'delete', 'nonexistent-id'],
        capture_output=True,
        text=True
    )

    assert result.returncode == 1
    assert 'Error: Task not found with ID: nonexistent-id' in result.stderr


def test_delete_missing_task_id():
    """Test delete without task ID shows argparse error"""
    result = subprocess.run(
        [sys.executable, '-m', 'src.main', 'delete'],
        capture_output=True,
        text=True
    )

    assert result.returncode == 2
    assert 'required: task_id' in result.stderr
```

#### Step 1.3: Run Tests - Verify RED Phase

**Command**:
```bash
python -m pytest tests/unit/test_task_service.py::test_delete_task_returns_deleted_task \
                tests/unit/test_task_service.py::test_delete_task_removes_from_storage \
                tests/unit/test_task_service.py::test_delete_task_nonexistent_id_raises_keyerror \
                tests/unit/test_task_service.py::test_delete_task_works_for_any_status \
                tests/unit/test_task_service.py::test_delete_task_with_unicode \
                tests/unit/test_task_service.py::test_delete_task_only_removes_specified_task \
                tests/integration/test_delete_task_integration.py -v
```

**Expected Result**: ‚ùå **ALL TESTS MUST FAIL**
- Reason: `delete_task()` function doesn't exist yet
- Error: `ImportError` or `AttributeError`

**Validation**: If tests pass, STOP - tests are not correctly detecting missing functionality.

---

### Phase 2: GREEN - Implement Minimal Code

**Mandate**: Write ONLY enough code to make tests pass. No extra features, no premature optimization.

#### Step 2.1: Implement Service Layer Function

**File**: `src/services/task_service.py`

**Add Function** (after existing functions):

```python
def delete_task(task_id: str) -> Task:
    """
    Delete a task from in-memory storage.

    Args:
        task_id: The task's unique identifier

    Returns:
        Task: The deleted task object (captured before removal)

    Raises:
        KeyError: If task ID not found
    """
    # Validate task exists
    if task_id not in _tasks:
        raise KeyError(f"Task not found with ID: {task_id}")

    # Remove from storage and capture deleted task
    deleted_task = _tasks.pop(task_id)

    return deleted_task
```

**Validation**: Run unit tests only
```bash
python -m pytest tests/unit/test_task_service.py::test_delete_task_returns_deleted_task \
                tests/unit/test_task_service.py::test_delete_task_removes_from_storage \
                tests/unit/test_task_service.py::test_delete_task_nonexistent_id_raises_keyerror \
                tests/unit/test_task_service.py::test_delete_task_works_for_any_status \
                tests/unit/test_task_service.py::test_delete_task_with_unicode \
                tests/unit/test_task_service.py::test_delete_task_only_removes_specified_task -v
```

**Expected**: ‚úÖ All 6 unit tests should now PASS

#### Step 2.2: Implement CLI Command

**File**: `src/cli/delete_task.py` (NEW FILE)

**Content**:
```python
import argparse
import sys

from src.services.task_service import delete_task


def delete_task_command(args: list[str] = None):
    """
    CLI command to delete an existing task by ID.

    Args:
        args: Command-line arguments (None = use sys.argv)

    Exit Codes:
        0: Success (task deleted)
        1: Error (task not found)
        2: Usage error (argparse validation failed)
    """
    parser = argparse.ArgumentParser(
        description="Delete an existing task by its unique ID",
        prog='todo delete'
    )

    # Positional argument
    parser.add_argument(
        'task_id',
        type=str,
        help='Unique task identifier (UUID)'
    )

    # Parse arguments
    parsed_args = parser.parse_args(args)

    # Call service layer
    try:
        deleted_task = delete_task(parsed_args.task_id)

        # Display success message
        print("Task deleted successfully!")
        print(f"ID: {deleted_task.id}")
        print(f"Title: {deleted_task.title}")
        print(f"Description: {deleted_task.description if deleted_task.description else '(none)'}")
        print(f"Status: {deleted_task.status.value.capitalize()}")

        sys.exit(0)

    except KeyError:
        print(f"Error: Task not found with ID: {parsed_args.task_id}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    delete_task_command()
```

#### Step 2.3: Update Main Router

**File**: `src/main.py`

**Update 1** - Add to help text (line ~8):
```python
print("Commands: add, view, update, delete", file=sys.stderr)
```

**Update 2** - Add routing (after update command block, before else):
```python
elif command == 'delete':
    from src.cli.delete_task import delete_task_command
    delete_task_command(sys.argv[2:])
```

**Update 3** - Add to error message (line ~21):
```python
print("Available commands: add, view, update, delete", file=sys.stderr)
```

#### Step 2.4: Run All Tests - Verify GREEN Phase

**Command**:
```bash
python -m pytest tests/unit/test_task_service.py::test_delete_task_returns_deleted_task \
                tests/unit/test_task_service.py::test_delete_task_removes_from_storage \
                tests/unit/test_task_service.py::test_delete_task_nonexistent_id_raises_keyerror \
                tests/unit/test_task_service.py::test_delete_task_works_for_any_status \
                tests/unit/test_task_service.py::test_delete_task_with_unicode \
                tests/unit/test_task_service.py::test_delete_task_only_removes_specified_task \
                tests/integration/test_delete_task_integration.py -v
```

**Expected Result**: ‚úÖ **ALL 10 TESTS MUST PASS**

**Validation**: If any test fails, debug and fix BEFORE proceeding to refactor phase.

---

### Phase 3: REFACTOR - Clean Up Code

**Mandate**: Improve code quality while keeping tests green. NO new functionality.

#### Step 3.1: Review Code for Issues

**Check for**:
- [ ] DRY violations (duplicated code)
- [ ] Naming consistency with existing features
- [ ] Documentation completeness (docstrings)
- [ ] Type hints present
- [ ] Error messages match specification exactly

#### Step 3.2: Refactor if Needed

**Common Refactorings** (only if needed):
- Extract constants for repeated strings
- Improve variable names for clarity
- Add missing docstrings or type hints
- Simplify complex expressions

**After Each Change**: Run all tests to ensure still green

#### Step 3.3: Final Test Run

**Command**:
```bash
python -m pytest tests/ -v
```

**Expected**: ‚úÖ All tests pass (including existing Add Task, View Task List, and Update Task tests)

---

## Manual Testing Checklist

After automated tests pass, perform manual validation:

### Success Scenarios

- [ ] Create task, then delete it ‚Üí Displays correct confirmation message
- [ ] Delete task shows all fields (ID, title, description, status)
- [ ] Description shows "(none)" when empty
- [ ] Status is capitalized (Complete/Incomplete)

### Error Scenarios

- [ ] Delete non-existent ID ‚Üí Displays error "Error: Task not found with ID: <id>"
- [ ] Delete without task ID ‚Üí Shows argparse usage error
- [ ] Exit codes: 0 (success), 1 (not found), 2 (missing arg)

### Help and Unicode

- [ ] `delete --help` displays correct usage information
- [ ] Delete task with Unicode ‚Üí Displays correctly in confirmation

---

## Coverage Verification

**Run Coverage Report**:
```bash
python -m pytest --cov=src tests/
```

**Minimum Requirements**:
- Service layer (`src/services/task_service.py`): ‚â• 90% coverage
- CLI layer (`src/cli/delete_task.py`): ‚â• 80% coverage

**Note**: CLI coverage may be lower due to in-process testing pattern (Phase I constraint).

---

## Success Criteria Validation

Before marking feature complete, verify all success criteria from `spec.md`:

- [ ] **SC-001**: Users can delete a task in a single command using the task ID
- [ ] **SC-002**: Deleted task immediately disappears from task list views
- [ ] **SC-003**: System provides clear confirmation message showing what was deleted
- [ ] **SC-004**: System provides clear error messages for all failure scenarios
- [ ] **SC-005**: Deletion operation completes in under 1 second
- [ ] **SC-006**: Unicode characters in task data are correctly displayed
- [ ] **SC-007**: Command help documentation clearly explains usage

---

## Common Pitfalls

### ‚ùå Pitfall 1: Writing Implementation Before Tests
**Problem**: Violates Constitution Principle V (Test-First Development)
**Solution**: ALWAYS write tests first, run them to verify they fail, THEN implement

### ‚ùå Pitfall 2: Tests Pass Immediately (No RED Phase)
**Problem**: Tests are not detecting missing functionality (false positives)
**Solution**: Review tests, ensure they actually call the functionality being tested

### ‚ùå Pitfall 3: Adding Extra Features
**Problem**: Implementing features not in specification (scope creep)
**Solution**: Follow specification exactly, no additional features

### ‚ùå Pitfall 4: Manual Coding
**Problem**: Human writes code instead of AI
**Solution**: All code MUST be generated via `/sp.implement` command (Claude Code only)

### ‚ùå Pitfall 5: Skipping Refactor Phase
**Problem**: Code quality issues accumulate
**Solution**: Always review and refactor while tests are green

---

## Next Steps

After implementation complete and all tests pass:

1. ‚úÖ Mark all tasks complete in `tasks.md`
2. ‚úÖ Run full test suite to verify no regressions
3. ‚úÖ Validate all success criteria met
4. ‚úÖ Commit changes with descriptive message
5. ‚è≠Ô∏è Proceed to next feature or Phase II planning

---

## References

- Specification: `specs/004-delete-task/spec.md`
- Implementation Plan: `specs/004-delete-task/plan.md`
- Research Decisions: `specs/004-delete-task/research.md`
- Data Model: `specs/004-delete-task/data-model.md`
- CLI Contract: `specs/004-delete-task/contracts/cli-interface.md`
- Task Decomposition: `specs/004-delete-task/tasks.md` (generated by `/sp.tasks`)
- Constitution: `.specify/memory/constitution.md`
